# mufy

#### 个人用私库，转载时请标明来源(星冕 or StarCrown or 糖浆)

来都来了给颗星星再走吧QAQ

<details>
<summary>历史更新记录</summary>

## 2025-4-18 添加了音乐播放器+歌词动效的代码

audio.html - 复古档案风格，适用于中英双语歌词

audio cyber.html - 赛博朋克霓虹风格，适用于中日双语歌词

~~想要纯中文显示的拿着代码去问d指导吧，我懒（）~~

## 2025-4-21 上传了一份完整的代码，包括HTML+CSS+JS内容

暗戳戳推一下自己的卡→[监狱4+1|泰坦诸神，永堕塔尔塔罗斯](https://chat.mufy.ai/chat?roleId=29fc007a-cdcd-4ab9-bb69-323937fa841d)

因为有人发现自己的代码塞进小剧场里用不了，用作参考对比

</details>

## 2025-4-24 上传了水墨风格（其实就是白+黑+一丢丢红的配色）的音乐播放器风格

audio ink.html - 白+黑+一点点红，适用于中文歌词

以及代码有折叠栏的时候放入mufy的渲染区（小剧场）里时出现画面显示不全情况的解决方案

<details>
<summary>妙手回春啊哈基米医生</summary>

**问题分析：**

核心问题在于，当 iframe 内部的内容高度发生变化时（例如折叠栏展开/收起），iframe 元素的 `height` 属性不会自动更新。这个 `height` 是由包含 iframe 的父页面控制的。因此，子页面需要一种方式**通知**父页面：“我的内容高度变了，请调整我的框架大小”。由于子页面无法直接操作父页面的 DOM 或调用其函数（尤其是在跨域场景下，或不清楚父页面结构时），需要间接的通信方式。

**实例分析：**

*   **赛博朋克实例 (有效原因):**
    1.  **明确的触发时机:** 在所有可能改变内容高度的操作后（折叠栏切换、标签页切换、通讯消息显示/隐藏、图片加载、初始加载），都调用了 `requestHeightUpdate` 函数。
    2.  **通信机制:** 使用 `window.dispatchEvent(new Event('resize'))`。这在 iframe 内部触发了一个标准的 `resize` 事件。
    3.  **父页面依赖:** **这种方法成功的关键在于父页面必须有相应的 JavaScript 代码来监听 iframe 的 `contentWindow` 上的 `resize` 事件。** 监听到事件后，父页面需要主动去获取 iframe 的 `document.body.scrollHeight` 并设置 iframe 的 `style.height`。子页面本身不知道父页面是否在监听，它只是发出了信号。
    4.  **符合约束:** 子页面不需要知道父页面的任何信息（iframe ID 等），它只管在自己的 `window` 上派发事件。

*   **水墨风格实例 (初始问题 & 解决后):**
    1.  **初始问题:** 折叠栏展开/收起时，没有通知父页面高度变化，导致父页面没有调整 iframe 高度，内容显示不全。
    2.  **应用修复:** 加入了与赛博朋克实例相同的 `requestHeightUpdate` 函数和调用逻辑后，问题得到解决（前提是父页面有对应的监听处理）。

**通用解法总结：**

在子页面无法获取父页面具体信息的情况下，子页面需要主动发送“高度变化”的信号给父页面。有两种主要策略：

1.  **策略一：派发 `resize` 事件 (Event Dispatching - 如实例所示)**
    *   **子页面做的事:** 在内容高度可能变化时，通过 `window.dispatchEvent(new Event('resize'))` 触发事件。
    *   **优点:** 实现简单，子页面代码量少。
    *   **缺点:**
        *   **严重依赖父页面实现:** 父页面必须编写特定的代码来监听 `iframe.contentWindow` 的 `resize` 事件并手动获取 `scrollHeight`。这不是一个普遍的或标准的 iframe 高度自适应方法。
        *   **信号模糊:** 只发送了一个“可能变化”的信号，没有传递具体高度值。父页面需要自己计算。
        *   **潜在冲突:** 如果父页面或其使用的库也在监听 `resize` 事件，可能会产生干扰。
    *   **适用场景:** 当你能控制父页面，并且父页面愿意或已经实现了监听 `iframe.contentWindow.resize` 的逻辑时。

2.  **策略二：使用 `window.postMessage` (推荐的通用方法)**
    *   **子页面做的事:** 在内容高度可能变化时，计算 `document.body.scrollHeight`，然后通过 `window.parent.postMessage({ type: 'iframeResize', height: newHeight }, '*')` 发送包含高度的消息给父窗口。
    *   **优点:**
        *   **标准通信:** 这是 W3C 标准的跨窗口/跨域通信方式。
        *   **传递数据:** 直接将计算好的高度传递给父页面，父页面无需再次计算。
        *   **更清晰:** 消息可以包含类型（如 `'iframeResize'`)，父页面可以根据类型处理不同消息。
        *   **更健壮:** 不依赖特定的事件监听，父页面只需监听标准的 `message` 事件。
    *   **缺点:**
        *   子页面代码稍微多一点（需要计算高度和构建消息）。
        *   父页面仍然需要编写监听 `message` 事件的代码。
        *   安全性注意：使用 `*` 作为 `targetOrigin` 允许任何父窗口接收消息。如果可能，应指定父窗口的确切来源 (e.g., `'https://parent.example.com'`) 以提高安全性，但这与“无法获取父框架信息”的约束略有冲突。在无法确定父来源时，`*` 是必要的。
    *   **适用场景:** **推荐作为通用解决方案**，尤其是在不确定父页面实现、跨域场景或需要更明确通信时。

</details>

